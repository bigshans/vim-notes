java-concurrency

# 第一部分

## 第二章　线程安全性

* 原子性
   - 竞态条件：由于不恰当的执行时序而造成不正确的结果。
   - 复合操作
     > 假定又两个操作A和Ｂ，如果从执行A的线程来看，当另一个线程执行Ｂ时，要么将B全部执行完，要么完全不执行，那么Ａ和Ｂ对彼此来说是原子的。
* 加锁机制
   - 内置锁
　 {{{java
    synchronized (lock) {
       // 访问或者修改共享变量
    }
   }}}
   - 重入
　　内置锁是可重入的，一个线程可以反复请求获取它已经获得的锁，并且这个请求会成功。
* 活跃与性能

### 第三章　对象的共享

* 可见性
   - 重排序
      - as-if-serial
      > 在没有同步的情况下，编译器、处理器以及运行时都可能对操作的执行顺序进行一些意想不到的调整。
      > 在缺乏足够同步的多线程程序中，想要对内存操作的执行顺序进行判断，几乎无法得出正确的结论。
   - volatile
      > 将变量声明为 volatile 
