MySQL

MySQL 分三层。
1) 连接处理、授权认证、安全等模块
2) MySQL核心服务，包括查询解析、分析优化、缓存以及所有的内置函数，所有的跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
3) 存储引擎

# 读写锁
共享锁和排他锁，也叫读锁和写锁。读锁是共享的，互相不阻塞，但写锁是阻塞其他的读锁和写锁。

# 锁粒度
1) 表锁：会锁定整张表，是开销最小的锁。存储引擎可以管理自己的锁，但MySQL还是会使用各种有效的表锁来实现不同的目的。例如，ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。
2) 行级锁：可以最大限度支持并发，但开销也大。

# 事务
* ACID
   * 原子性(atomicity)：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部成功，要么全部失败，对于一个事务来说不可能只执行其中的一部分。
   * 一致性(consistency)：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
   * 隔离性(isolation)：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。
   * 持久性(durablility)：一旦事务提交，所做的修改将会永久保存到数据库中。
* 隔离级别
   * READ UNCOMMITTED(未提交读)：事务的修改，即使没有提交，对其他事务来说也是可见的。
   * READ COMMITTED(提交读)：一个事务开始时，只能看见已经提交了的事务的修改。
   * REPEATABLE READ(可重复读)：该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读无法解决幻读问题。这是MySQL的默认级别。
   * SERIALIZABLE(可串行化)：强制事务串行执行。
* MySQL 如何开启事务
{{{sql
START TRANSACTION;
SELECT balance FROM checking WHERE customer_id = 10233276;
SELECT checing SET balance = balance - 200.0 WHERE customer_id = 10233276;
UPDATE savings SET balance = balance + 200.0 WHERE customer_id = 10233276;
COMMIT;
}}}
* 自动提交
在当前连接中查看自动提交模式是否开启。
{{{sql
   SHOW VARIABLES LIKE 'AUTOCOMMIT';
}}}
1或者ON表示启用，0或者OFF表示禁用。
使用下列语句修改隔离级别：
{{{sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
}}}
* ACID 实现原理
   * 原子性：undo log，从而达到回滚
   * 持久性：redo log，从而达到故障后恢复
   * 隔离性：锁机制，多版本并发控制(MVCC)，使用锁以及MVCC，运用的优化思想有读写分离，读读并发，读写并行。
   * 一致性：保证原子性、持久性和隔离性，数据库本身提供保障，并在应用层提供保障。

# MySQL 的存储引擎

* InnoDB
   * 采用MVCC来支持高并发，并且实现了四个标准的隔离级别，其默认级别是(REPEATABLE READ)。
* MyISAM
   * 加锁与并发：表级锁
   * 修复
   * 索引特性
   * 延迟更新索引键

# 范式与反范式

* 范式
   * 第一范式(1NF)：强调列的原子性，即列不能够再分成其他几列。
   * 第二范式(2NF)：首先是1FN，另外包含两个部分，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖主键，而不能依赖主键的一部分。
   * 第三范式(3NF)：任何非主属性不依赖于其他非主属性。
   > 举个例子，订单详情表有订单号，产品号，产品单价，产品数量，订单总价，产品名，显然，产品单价、产品名只依赖于产品号，而不依赖于订单号和产号，而产品数量、产品总价完全依赖于订单号和产品号，因此不符合2NF。
   > 考虑一个订单表，有订单号，订单时间，消费者号，消费者名，消费者地址，消费者城市，符合2NF，但不符合3NF，消费者名，消费者地址，消费者城市依赖于消费者号，因此不符合3NF。

* 反范式：因为所有的数据都集中在一张表中，可以有效的避免关联。

# 索引

* 索引类型
   * B-Tree 索引
      一棵m阶的B-tree有如下特性：
      1) 每个节点最多有m个孩子
      2) 除了根节点和叶子节点外，其它每个节点至少有ceil(m/2)个孩子
      3) 若根节点不是叶子节点，至少有2个孩子
      4) 所有叶子节点都在同一层，且不包含其它关键字信息
      5) 每个非终端节点包含n个关键字信息
      6) 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1
      7) ki为关键字，且关键字升序排序。
      8) Pi为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)
   * B+Tree 索引
      与B-Tree相比有一下不同
      1) 非叶子节点只存储键值信息
      2) 所有叶子节点之间都只有一个链指针
      3) 数据记录都存放在叶子节点中
   * 可以使用 B-Tree 索引的查询类型
      * 全值匹配
      * 匹配最左前缀：即只使用索引的第一列
      * 匹配列前缀：只匹配某一列的值的开头部分
      * 匹配范围值：只使用索引的第一列
      * 精确匹配某一列并范围匹配另外一列
      * 只访问索引的查询
   * 哈希索引
      * 基于哈希表实现，只有精确匹配索引所有列的查询才有效。
   * 空间数据索引(R-Tree)
   * 全文索引
   * 其他索引类别

